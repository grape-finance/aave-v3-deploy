{
  "address": "0x9d53d4175a6711C6a7c2ba6d97e8e8B9aF1D9AE7",
  "abi": [],
  "transactionHash": "0x2705cbd9da522b4cd8cf1635b266a8dbe1e209d95af2397418c2bdeee134b055",
  "receipt": {
    "to": null,
    "from": "0x4Aa6Da4ca5d76e8d5e3ACD11B92Ab22D564F1fcb",
    "contractAddress": "0x9d53d4175a6711C6a7c2ba6d97e8e8B9aF1D9AE7",
    "transactionIndex": 3,
    "gasUsed": "104920",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4848c68750f0c65538a869c52d3b02a41fb079dc4f1f9eb5457d3d8c39275340",
    "transactionHash": "0x2705cbd9da522b4cd8cf1635b266a8dbe1e209d95af2397418c2bdeee134b055",
    "logs": [],
    "blockNumber": 108646451,
    "cumulativeGasUsed": "317656",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "1eaa4365c44e38f8790053afb1c34d22",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"Aave\",\"kind\":\"dev\",\"methods\":{},\"title\":\"CalldataLogic library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core-v3/protocol/libraries/logic/CalldataLogic.sol\":\"CalldataLogic\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"contracts/core-v3/protocol/libraries/logic/CalldataLogic.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title CalldataLogic library\\r\\n * @author Aave\\r\\n * @notice Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction\\r\\n */\\r\\nlibrary CalldataLogic {\\r\\n  /**\\r\\n   * @notice Decodes compressed supply params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed supply params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The amount to supply\\r\\n   * @return The referralCode\\r\\n   */\\r\\n  function decodeSupplyParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256, uint16) {\\r\\n    uint16 assetId;\\r\\n    uint256 amount;\\r\\n    uint16 referralCode;\\r\\n\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      referralCode := and(shr(144, args), 0xFFFF)\\r\\n    }\\r\\n    return (reservesList[assetId], amount, referralCode);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed supply params to standard params along with permit params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed supply with permit params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The amount to supply\\r\\n   * @return The referralCode\\r\\n   * @return The deadline of the permit\\r\\n   * @return The V value of the permit signature\\r\\n   */\\r\\n  function decodeSupplyWithPermitParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256, uint16, uint256, uint8) {\\r\\n    uint256 deadline;\\r\\n    uint8 permitV;\\r\\n\\r\\n    assembly {\\r\\n      deadline := and(shr(160, args), 0xFFFFFFFF)\\r\\n      permitV := and(shr(192, args), 0xFF)\\r\\n    }\\r\\n    (address asset, uint256 amount, uint16 referralCode) = decodeSupplyParams(reservesList, args);\\r\\n\\r\\n    return (asset, amount, referralCode, deadline, permitV);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed withdraw params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed withdraw params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The amount to withdraw\\r\\n   */\\r\\n  function decodeWithdrawParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256) {\\r\\n    uint16 assetId;\\r\\n    uint256 amount;\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n    }\\r\\n    if (amount == type(uint128).max) {\\r\\n      amount = type(uint256).max;\\r\\n    }\\r\\n    return (reservesList[assetId], amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed borrow params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed borrow params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The amount to borrow\\r\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\r\\n   * @return The referralCode\\r\\n   */\\r\\n  function decodeBorrowParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256, uint256, uint16) {\\r\\n    uint16 assetId;\\r\\n    uint256 amount;\\r\\n    uint256 interestRateMode;\\r\\n    uint16 referralCode;\\r\\n\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      interestRateMode := and(shr(144, args), 0xFF)\\r\\n      referralCode := and(shr(152, args), 0xFFFF)\\r\\n    }\\r\\n\\r\\n    return (reservesList[assetId], amount, interestRateMode, referralCode);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed repay params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed repay params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The amount to repay\\r\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\r\\n   */\\r\\n  function decodeRepayParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256, uint256) {\\r\\n    uint16 assetId;\\r\\n    uint256 amount;\\r\\n    uint256 interestRateMode;\\r\\n\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      amount := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      interestRateMode := and(shr(144, args), 0xFF)\\r\\n    }\\r\\n\\r\\n    if (amount == type(uint128).max) {\\r\\n      amount = type(uint256).max;\\r\\n    }\\r\\n\\r\\n    return (reservesList[assetId], amount, interestRateMode);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed repay params to standard params along with permit params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed repay with permit params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The amount to repay\\r\\n   * @return The interestRateMode, 1 for stable or 2 for variable debt\\r\\n   * @return The deadline of the permit\\r\\n   * @return The V value of the permit signature\\r\\n   */\\r\\n  function decodeRepayWithPermitParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256, uint256, uint256, uint8) {\\r\\n    uint256 deadline;\\r\\n    uint8 permitV;\\r\\n\\r\\n    (address asset, uint256 amount, uint256 interestRateMode) = decodeRepayParams(\\r\\n      reservesList,\\r\\n      args\\r\\n    );\\r\\n\\r\\n    assembly {\\r\\n      deadline := and(shr(152, args), 0xFFFFFFFF)\\r\\n      permitV := and(shr(184, args), 0xFF)\\r\\n    }\\r\\n\\r\\n    return (asset, amount, interestRateMode, deadline, permitV);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed swap borrow rate mode params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed swap borrow rate mode params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The interest rate mode, 1 for stable 2 for variable debt\\r\\n   */\\r\\n  function decodeSwapBorrowRateModeParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, uint256) {\\r\\n    uint16 assetId;\\r\\n    uint256 interestRateMode;\\r\\n\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      interestRateMode := and(shr(16, args), 0xFF)\\r\\n    }\\r\\n\\r\\n    return (reservesList[assetId], interestRateMode);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed rebalance stable borrow rate params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed rabalance stable borrow rate params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return The address of the user to rebalance\\r\\n   */\\r\\n  function decodeRebalanceStableBorrowRateParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, address) {\\r\\n    uint16 assetId;\\r\\n    address user;\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      user := and(shr(16, args), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n    }\\r\\n    return (reservesList[assetId], user);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed set user use reserve as collateral params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args The packed set user use reserve as collateral params\\r\\n   * @return The address of the underlying reserve\\r\\n   * @return True if to set using as collateral, false otherwise\\r\\n   */\\r\\n  function decodeSetUserUseReserveAsCollateralParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args\\r\\n  ) internal view returns (address, bool) {\\r\\n    uint16 assetId;\\r\\n    bool useAsCollateral;\\r\\n    assembly {\\r\\n      assetId := and(args, 0xFFFF)\\r\\n      useAsCollateral := and(shr(16, args), 0x1)\\r\\n    }\\r\\n    return (reservesList[assetId], useAsCollateral);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Decodes compressed liquidation call params to standard params\\r\\n   * @param reservesList The addresses of all the active reserves\\r\\n   * @param args1 The first half of packed liquidation call params\\r\\n   * @param args2 The second half of the packed liquidation call params\\r\\n   * @return The address of the underlying collateral asset\\r\\n   * @return The address of the underlying debt asset\\r\\n   * @return The address of the user to liquidate\\r\\n   * @return The amount of debt to cover\\r\\n   * @return True if receiving aTokens, false otherwise\\r\\n   */\\r\\n  function decodeLiquidationCallParams(\\r\\n    mapping(uint256 => address) storage reservesList,\\r\\n    bytes32 args1,\\r\\n    bytes32 args2\\r\\n  ) internal view returns (address, address, address, uint256, bool) {\\r\\n    uint16 collateralAssetId;\\r\\n    uint16 debtAssetId;\\r\\n    address user;\\r\\n    uint256 debtToCover;\\r\\n    bool receiveAToken;\\r\\n\\r\\n    assembly {\\r\\n      collateralAssetId := and(args1, 0xFFFF)\\r\\n      debtAssetId := and(shr(16, args1), 0xFFFF)\\r\\n      user := and(shr(32, args1), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n\\r\\n      debtToCover := and(args2, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      receiveAToken := and(shr(128, args2), 0x1)\\r\\n    }\\r\\n\\r\\n    if (debtToCover == type(uint128).max) {\\r\\n      debtToCover = type(uint256).max;\\r\\n    }\\r\\n\\r\\n    return (\\r\\n      reservesList[collateralAssetId],\\r\\n      reservesList[debtAssetId],\\r\\n      user,\\r\\n      debtToCover,\\r\\n      receiveAToken\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0xc43d0970ebcb437c08014f29d08cff3aa88d6e2c078420405d8223ab81377f71\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220617c0f27908940576478d4f52d931996b7d2ad9228a4744f42eb91bfcdb09ec464736f6c634300080a0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220617c0f27908940576478d4f52d931996b7d2ad9228a4744f42eb91bfcdb09ec464736f6c634300080a0033",
  "devdoc": {
    "author": "Aave",
    "kind": "dev",
    "methods": {},
    "title": "CalldataLogic library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Library to decode calldata, used to optimize calldata size in L2Pool for transaction cost reduction",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}